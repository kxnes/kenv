// Package gen contains instruments for generation.
package gen

import (
	"fmt"
	"os"
	"path"
	"strings"
	"text/template"

	"github.com/kxnes/kenv/internal/conv"
	"github.com/kxnes/kenv/internal/parser"
	"github.com/kxnes/kenv/internal/types"
)

// Recv represents receiver (target struct).
type Recv struct {
	Name string
	Type string
}

// TmplData contains data for passing inside templates.
type TmplData struct {
	Recv  *Recv
	Title string
	Name  string
	Field *types.Field
}

const (
	predefined = "predefined"
	construct  = "construct"
)

// generator uses as inner generator for code generation.
type generator struct {
	p          *parser.Parser
	needImport bool
}

// CodeGen generates environment helpers by calling inner generator.
func CodeGen(p *parser.Parser) error {
	fields := p.ParsedFields()
	if fields == nil {
		if err := p.Parse(); err != nil {
			return err
		}
	}

	gen := generator{p: p}

	return gen.generateFile()
}

// generateFile generates environment helpers by result of parsing target environment.
func (g *generator) generateFile() error {
	data := g.generateTmplData(g.p.ParsedFields())

	dir, file := path.Split(g.p.Filename())
	out := file[:strings.LastIndex(file, ".")] + "gen.go"

	f, err := os.Create(path.Join(dir, out))
	if err != nil {
		return err
	}

	defer func() { _ = f.Close() }()

	mustWrite(fmt.Fprintf(f, "// Code generated by kenv for %s target. DO NOT EDIT.\n", g.p.Target()))
	mustWrite(fmt.Fprintf(f, "package %s\n\n", g.p.Package()))

	if g.needImport {
		imports := strings.Join(conv.GetPredefinedImport(), "\n\t")
		mustWrite(fmt.Fprintf(f, "import (\n\t%s\n)\n", imports))
	}

	templates := map[string]*template.Template{
		// for predefined convert functions
		predefined: template.Must(template.New(predefined).Parse(Get)),
		// for New method
		construct: template.Must(template.New(construct).Parse(New)),
		// for other
		types.Want:   template.Must(template.New(types.Want).Parse(Want)),
		types.Must:   template.Must(template.New(types.Must).Parse(Must)),
		types.Secret: template.Must(template.New(types.Secret).Parse(Secret)),
	}

	for key, d := range data {
		must(templates[d.Name].Execute(f, d))

		if d.Name == predefined {
			delete(data, key)
		}
	}

	must(templates[construct].Execute(f, struct {
		Recv *Recv
		Data map[string]*TmplData
	}{g.makeRecv(), data}))

	return nil
}

// makeRecv returns new Recv from parsing results.
func (g *generator) makeRecv() *Recv {
	return &Recv{
		Type: g.p.Target(),
		Name: strings.ToLower(g.p.Target()[:1]),
	}
}

// generateTmplData converts parsed fields into template data.
func (g *generator) generateTmplData(fields map[string]*types.Field) map[string]*TmplData {
	data := make(map[string]*TmplData)
	recv := g.makeRecv()

	for _, f := range fields {
		title := strings.Title(strings.ReplaceAll(f.Type, ".", ""))

		if strings.HasPrefix(f.Func, "kenv.") {
			g.needImport = true

			if _, ok := data[f.Type]; !ok {
				data[f.Type] = &TmplData{Recv: recv, Title: title, Name: predefined, Field: f}
			}
		}

		action := f.Action
		switch action {
		case types.Want:
			action = "Want"
		case types.Must:
			action = "Must"
		case types.Secret:
			action = "Secret"
		}

		// for predefined functions only
		fn := f.Func
		if _, ok := data[f.Type]; ok {
			fn = "Get" + title
		}

		data[f.Name] = &TmplData{Recv: recv, Title: title, Name: f.Action, Field: &types.Field{
			Name:   f.Name,
			Type:   f.Type,
			Func:   fn,
			EnvVar: f.EnvVar,
			Action: action,
		}}
	}

	return data
}

// mustWrite panics on unexpected errors during write operations.
func mustWrite(_ int, err error) {
	must(err)
}

// must panics if err occurred.
func must(err error) {
	if err != nil {
		panic(err)
	}
}
