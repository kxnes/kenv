package gen

import (
	"fmt"
	"os"
	"path"
	"strings"
	"text/template"

	"kenv/kenv/internal/conv"
	"kenv/kenv/internal/parser"
	"kenv/kenv/internal/types"
)

const (
	Get = `
// Get{{ .Title }} decorates predefined by kenv convert function to follow one code style.
func ({{ .Recv.Name }} *{{ .Recv.Type }}) Get{{ .Title }}(s string) ({{ .Field.Type }}, error) {
	return {{ .Field.ConvFunc }}(s)
}
`
	New = `
// New returns new {{ .Recv.Type }}. 
func New() *{{ .Recv.Type }} {
	{{ .Recv.Name }} := new({{ .Recv.Type }})
	{{- range $key, $value := .Data}}
	{{ $value.Recv.Name}}.{{ $value.Field.Name }} = {{ $value.Recv.Name }}.{{ $value.Field.Action }}{{ $value.Title }}("{{ $value.Field.EnvVar }}")
	{{- end}}
	return {{ .Recv.Name }}
}
`
	Want = `
// Want{{ .Title }} returns the {{ .Field.Type }} environment variable
// or default value of {{ .Field.Type }} otherwise. No checks here.
func ({{ .Recv.Name }} *{{ .Recv.Type }}) Want{{ .Title }}(key string) {{ .Field.Type }} {
	env, _ := os.LookupEnv(key)
	val, _ := {{ .Recv.Name }}.{{ .Field.ConvFunc }}(env)
	return val
}
`
	Must = `
// Must{{ .Title }} returns the {{ .Field.Type }} environment variable
// if it is exist and valid or panics otherwise.
func ({{ .Recv.Name }} *{{ .Recv.Type }}) Must{{ .Title }}(key string) {{ .Field.Type }} {
	env, ok := os.LookupEnv(key)
	if !ok {
		panic("error missing " + key)
	}

	val, err := {{ .Recv.Name }}.{{ .Field.ConvFunc }}(env)
	if err != nil {
		panic("error convert " + key)
	}

	return val
}
`
	Secret = `
// Secret{{ .Title }} returns the {{ .Field.Type }} environment variable
// if it is exist and valid or panics otherwise.
// Also Secret{{ .Title }} immediately deletes it from environment.
func ({{ .Recv.Name }} *{{ .Recv.Type }})Secret{{ .Title }}(key string) {{ .Field.Type }} {
	env, ok := os.LookupEnv(key)
	if !ok {
		panic("error missing " + key)
	}
	_ = os.Unsetenv(key)

	val, err := {{ .Recv.Name }}.{{ .Field.ConvFunc }}(env)
	if err != nil {
		panic("error convert " + key)
	}

	return val
}
`
)

type Recv struct {
	Name string
	Type string
}

type TmplData struct {
	Recv  *Recv
	Title string
	Name  string
	Field *types.Field
}

const (
	predefined = "predefined"
	construct  = "construct"
)

type generator struct {
	p          *parser.Parser
	needImport bool
}

func CodeGen(p *parser.Parser) error {
	fields := p.ParsedFields()
	if fields == nil {
		if err := p.Parse(); err != nil {
			return err
		}
	}
	gen := generator{p: p}
	return gen.generateFile()
}

func (g *generator) generateFile() error {
	data := g.generateTmplData(g.p.ParsedFields())

	dir, file := path.Split(g.p.Filename())
	out := file[:strings.LastIndex(file, ".")] + "gen.go"
	f, err := os.Create(path.Join(dir, out))
	if err != nil {
		return err
	}

	defer func() { _ = f.Close() }()

	mustWrite(fmt.Fprintf(f, "// Code generated by kenv for %s target. DO NOT EDIT.\n", g.p.Target()))
	mustWrite(fmt.Fprintf(f, "package %s\n\n", g.p.Package()))

	if g.needImport {
		imports := strings.Join(conv.GetPredefinedImport(), "\n\t")
		mustWrite(fmt.Fprintf(f, "import (\n\t%s\n)\n", imports))
	}

	templates := map[string]*template.Template{
		// for predefined convert functions
		predefined: template.Must(template.New(predefined).Parse(Get)),
		// for New method
		construct: template.Must(template.New(construct).Parse(New)),
		// for other
		types.Want:   template.Must(template.New(types.Want).Parse(Want)),
		types.Must:   template.Must(template.New(types.Must).Parse(Must)),
		types.Secret: template.Must(template.New(types.Secret).Parse(Secret)),
	}

	for key, d := range data {
		must(templates[d.Name].Execute(f, d))
		if d.Name == predefined {
			delete(data, key)
		}
	}
	must(templates[construct].Execute(f, struct {
		Recv *Recv
		Data map[string]*TmplData
	}{g.makeRecv(), data}))

	return nil
}

func (g *generator) makeRecv() *Recv {
	return &Recv{
		Type: g.p.Target(),
		Name: strings.ToLower(g.p.Target()[:1]),
	}
}

func (g *generator) generateTmplData(fields map[string]*types.Field) map[string]*TmplData {
	data := make(map[string]*TmplData)
	recv := g.makeRecv()

	for _, f := range fields {
		title := strings.Title(strings.ReplaceAll(f.Type, ".", ""))
		if strings.HasPrefix(f.ConvFunc, "kenv.") {
			g.needImport = true
			if _, ok := data[f.Type]; ok {
				continue
			}

			data[f.Type] = &TmplData{Recv: recv, Title: title, Name: predefined, Field: f}
		}

		data[f.Name] = &TmplData{Recv: recv, Title: title, Name: f.Action, Field: f}

		switch f.Action {
		case types.Want:
			data[f.Name].Field.Action = "Want"
		case types.Must:
			data[f.Name].Field.Action = "Must"
		case types.Secret:
			data[f.Name].Field.Action = "Secret"
		}
	}

	return data
}

func mustWrite(_ int, err error) {
	must(err)
}

func must(err error) {
	if err != nil {
		panic(err)
	}
}
